#include "xparameters.h"
#include "xtmrctr.h"
#include "xintc.h"
#include "mb_interface.h"
#include "xil_printf.h"

// FFT
#define ADDR_FFT_START    0x80001dbcU
#define ADDR_FFT_END      0x800020c8U

// read_fsl_values_avg (grab)
#define ADDR_GRAB_START   0x800020c8U
#define ADDR_GRAB_END     0x8000221cU

// findNote
#define ADDR_NOTE_START   0x800025d0U
#define ADDR_NOTE_END     0x80002854U


typedef enum {
    SEG_GRAB = 0,
    SEG_FFT,
    SEG_NOTE,
    SEG_OTHER,
    SEG_COUNT
} segment_id_t;

static const char* segment_names[SEG_COUNT] = {
    "grab",
    "fft",
    "note",
    "other"
};

volatile unsigned long perf_counts[SEG_COUNT] = {0};

static XIntc   PerfIntc;
static XTmrCtr PerfTimer;

/*** Map PC to segment ***/
static segment_id_t perfmon_classify(uint32_t pc)
{
    if (pc >= ADDR_GRAB_START && pc < ADDR_GRAB_END) return SEG_GRAB;
    if (pc >= ADDR_FFT_START  && pc < ADDR_FFT_END)  return SEG_FFT;
    if (pc >= ADDR_NOTE_START && pc < ADDR_NOTE_END) return SEG_NOTE;
    return SEG_OTHER;
}

/*** Timer callback called by XTmrCtr_InterruptHandler ***/
static void perfmon_timer_callback(void *CallBackRef, u8 TmrCtrNumber)
{
    uint32_t pc;

    // pc = return address register (r14)
    asm("add %0, r0, r14" : "=r"(pc));

    segment_id_t seg = perfmon_classify(pc);
    perf_counts[seg]++;
}

/*** Initialize performance monitor ***/
int perfmon_init(void)
{
    int status;

    // Init timer used for sampling (use AXI_TIMER_1 for profiler)
    status = XTmrCtr_Initialize(&PerfTimer, XPAR_AXI_TIMER_1_DEVICE_ID);
    if (status != XST_SUCCESS) return status;

    // Hook our callback into the timer driver
    XTmrCtr_SetHandler(&PerfTimer, perfmon_timer_callback, &PerfTimer);

    // Auto-reload + interrupt mode
    XTmrCtr_SetOptions(&PerfTimer, 0,
        XTC_AUTO_RELOAD_OPTION | XTC_INT_MODE_OPTION);

    // Set sampling period:
    // e.g. sample every 10000 cycles => 0.1 ms at 100 MHz
    // (tune SAMPLE_TICKS if you want more/less granularity)
    const uint32_t SAMPLE_TICKS = 10000U;
    XTmrCtr_SetResetValue(&PerfTimer, 0, 0xFFFFFFFFU - SAMPLE_TICKS + 1U);

    // Init interrupt controller
    status = XIntc_Initialize(&PerfIntc, XPAR_INTC_0_DEVICE_ID);
    if (status != XST_SUCCESS) return status;

    // Connect timer interrupt handler to interrupt controller
    status = XIntc_Connect(
        &PerfIntc,
        XPAR_MICROBLAZE_0_AXI_INTC_AXI_TIMER_0_INTERRUPT_INTR,
        (XInterruptHandler)XTmrCtr_InterruptHandler,
        &PerfTimer
    );
    if (status != XST_SUCCESS) return status;

    XIntc_Start(&PerfIntc, XIN_REAL_MODE);
    XIntc_Enable(&PerfIntc, XPAR_MICROBLAZE_0_AXI_INTC_AXI_TIMER_0_INTERRUPT_INTR);

    // Enable interrupts globally on MicroBlaze
    microblaze_enable_interrupts();

    // Start the sampling timer
    XTmrCtr_Start(&PerfTimer, 0);

    return XST_SUCCESS;
}

/*** Print results (call from main when you want a snapshot) ***/
void perfmon_print_results(void)
{
    unsigned long total = 0;
    int i;
    for (i = 0; i < SEG_COUNT; i++) {
        total += perf_counts[i];
    }

    xil_printf("\r\n=== Performance Monitor Results ===\r\n");
    xil_printf("Total samples: %lu\r\n", total);

    for (i = 0; i < SEG_COUNT; i++) {
        float pct = 0.0f;
        if (total > 0) {
            pct = 100.0f * (float)perf_counts[i] / (float)total;
        }
        xil_printf("%s: %lu samples (%.1f %%)\r\n",
                   segment_names[i], perf_counts[i], pct);
    }
    xil_printf("===================================\r\n");
}
