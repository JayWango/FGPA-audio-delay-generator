//#include "fft.h"
//#include "complex.h"
//#include "trig.h"
//
//static float new_[512];
//static float new_im[512];
//
//float fft(float* q, float* w, int n, int m, float sample_f) {
//	int a,b,r,d,e,c;
//	int k,place;
//	a=n/2;
//	b=1;
//	int i,j;
//	float real=0,imagine=0;
//	float max,frequency;
//
//	// ORdering algorithm
//	for(i=0; i<(m-1); i++){
//		d=0;
//		for (j=0; j<b; j++){
//			for (c=0; c<a; c++){
//				e=c+d;
//				new_[e]=q[(c*2)+d];
//				new_im[e]=w[(c*2)+d];
//				new_[e+a]=q[2*c+1+d];
//				new_im[e+a]=w[2*c+1+d];
//			}
//			d+=(n/b);
//		}
//		for (r=0; r<n;r++){
//			q[r]=new_[r];
//			w[r]=new_im[r];
//		}
//		b*=2;
//		a=n/(2*b);
//	}
//	//end ordering algorithm
//
//	b=1;
//	k=0;
//	for (j=0; j<m; j++){
//	//MATH
//		for(i=0; i<n; i+=2){
//			if (i%(n/b)==0 && i!=0)
//				k++;
//			real=mult_real(q[i+1], w[i+1], cosine(-PI*k/b), sine(-PI*k/b));
//			imagine=mult_im(q[i+1], w[i+1], cosine(-PI*k/b), sine(-PI*k/b));
//			new_[i]=q[i]+real;
//			new_im[i]=w[i]+imagine;
//			new_[i+1]=q[i]-real;
//			new_im[i+1]=w[i]-imagine;
//
//		}
//		for (i=0; i<n; i++){
//			q[i]=new_[i];
//			w[i]=new_im[i];
//		}
//	//END MATH
//
//	//REORDER
//		for (i=0; i<n/2; i++){
//			new_[i]=q[2*i];
//			new_[i+(n/2)]=q[2*i+1];
//			new_im[i]=w[2*i];
//			new_im[i+(n/2)]=w[2*i+1];
//		}
//		for (i=0; i<n; i++){
//			q[i]=new_[i];
//			w[i]=new_im[i];
//		}
//	//END REORDER
//		b*=2;
//		k=0;
//	}
//
//	//find magnitudes
//	max=0;
//	place=1;
//	for(i=1;i<(n/2);i++) {
//		new_[i]=q[i]*q[i]+w[i]*w[i];
//		if(max < new_[i]) {
//			max=new_[i];
//			place=i;
//		}
//	}
//
//	float s=sample_f/n; //spacing of bins
//
//	frequency = (sample_f/n)*place;
//
//	//curve fitting for more accuarcy
//	//assumes parabolic shape and uses three point to find the shift in the parabola
//	//using the equation y=A(x-x0)^2+C
//	float y1=new_[place-1],y2=new_[place],y3=new_[place+1];
//	float x0=s+(2*s*(y2-y1))/(2*y2-y1-y3);
//	x0=x0/s-1;
//
//	if(x0 <0 || x0 > 2) { //error
//		return 0;
//	}
//	if(x0 <= 1)  {
//		frequency=frequency-(1-x0)*s;
//	}
//	else {
//		frequency=frequency+(x0-1)*s;
//	}
//
//	return frequency;
//}


#include "fft.h"
#include "trig.h"   // for PI, sine(), cosine()

#define FFT_MAX_N 512

// We only need this for storing magnitude^2 for peak finding.
// Size for max N = 512; safe for your 128-point case too.
static float mag2_buf[FFT_MAX_N];
static float tw_re[FFT_MAX_N / 2];
static float tw_im[FFT_MAX_N / 2];
static int tw_n = 0;

void fft_init(int n)
{
    int k;

    if (n > FFT_MAX_N) return;   // safety
    tw_n = n;

    // Precompute twiddles: W_N^k = exp(-j*2*pi*k/N) = cos(...) + j*sin(...)
    for (k = 0; k < n / 2; k++) {
        float angle = -2.0f * PI * (float)k / (float)n;
        tw_re[k] = cosine(angle);
        tw_im[k] = sine(angle);
    }
}

/* Reverse the lowest `bits` bits of x.
 * e.g. bit_reverse(3, 3) = 6 (0b011 -> 0b110)
 */
static unsigned bit_reverse(unsigned x, int bits)
{
    unsigned r = 0;
    int i;
    for (i = 0; i < bits; i++) {
        r = (r << 1) | (x & 1U);
        x >>= 1;
    }
    return r;
}

float fft(float* q, float* w, int n, int m, float sample_f)
{
    int i;

    /********** 1. Bit-reversal permutation (in-place) **********/
	for (i = 0; i < n; i++) {
		unsigned j = bit_reverse((unsigned)i, m);
		if (j > (unsigned)i) {
			float tmp = q[i];
			q[i] = q[j];
			q[j] = tmp;

			tmp = w[i];
			w[i] = w[j];
			w[j] = tmp;
		}
	}

	/********** 2. Iterative radix-2 FFT **********/
	int stage;
	for (stage = 1; stage <= m; stage++) {
		int mval = 1 << stage;    // 2^stage
		int half = mval >> 1;     // mval / 2
		int stride = tw_n / mval; // mapping into global twiddle table

		int k;
		for (k = 0; k < half; k++) {
			int idx = k * stride;
			float wr = tw_re[idx];
			float wi = tw_im[idx];

			int j;
			for (j = k; j < n; j += mval) {
				int t = j + half;

				float ur = q[j];
				float ui = w[j];
				float vr = q[t];
				float vi = w[t];

				// v * W
				float tr = wr * vr - wi * vi;
				float ti = wr * vi + wi * vr;

				q[j] = ur + tr;
				w[j] = ui + ti;
				q[t] = ur - tr;
				w[t] = ui - ti;
			}
		}
	}

	/********** 3. Magnitude^2 and peak detection **********/
	float max = 0.0f;
	int   place = 1;

	int limit = n / 2;
	if (limit > FFT_MAX_N - 1) limit = FFT_MAX_N - 1;

	for (i = 1; i < limit; i++) {
		float re = q[i];
		float im = w[i];
		float mag2 = re * re + im * im;
		mag2_buf[i] = mag2;

		if (mag2 > max) {
			max = mag2;
			place = i;
		}
	}

    // Base frequency from peak bin index
	float bin_width = sample_f / (float)n;
	float frequency = bin_width * (float)place;

	/********** 4. Parabolic interpolation **********/
	if (place > 1 && place < (limit - 1)) {
		float y1 = mag2_buf[place - 1];
		float y2 = mag2_buf[place];
		float y3 = mag2_buf[place + 1];

		float denom = (y1 - 2.0f * y2 + y3);
		if (denom != 0.0f) {
			float delta = 0.5f * (y1 - y3) / denom;
			frequency += delta * bin_width;
		}
	}

	return frequency;
}
